Index: vcg/space/index/kdtree/kdtree.h
===================================================================
--- vcg/space/index/kdtree/kdtree.h	(revision 5055)
+++ vcg/space/index/kdtree/kdtree.h	(working copy)
@@ -56,14 +56,14 @@
 	{
 		union {
                         //standard node
-			struct {
+			struct ano{
 				Scalar splitValue;
 				unsigned int firstChildId:24;
 				unsigned int dim:2;
 				unsigned int leaf:1;
 			};
                         //leaf
-			struct {
+			struct ano0{
 				unsigned int start;
 				unsigned short size;
 			};
Index: vcg/space/index/spatial_hashing.h
===================================================================
--- vcg/space/index/spatial_hashing.h	(revision 5055)
+++ vcg/space/index/spatial_hashing.h	(working copy)
@@ -27,29 +27,17 @@
 #include <vcg/space/index/grid_util.h>
 #include <vcg/space/index/grid_closest.h>
 //#include <map>
+#include <config.h>
 #include <vector>
 #include <algorithm>
-#ifdef _WIN32
- #ifndef __MINGW32__
-  #include <hash_map>
-  #define STDEXT stdext
- #else
-  #include <ext/hash_map>
-  #define STDEXT __gnu_cxx
- #endif
-#else  // We are in the *nix gcc branch
-#if (__GNUC__ ==4) && (__GNUC_MINOR__ > 3) && (defined(__DEPRECATED))
-  #undef __DEPRECATED // since gcc 4.4 <ext/hash_map> was deprecated and generate warnings. Relax Deprecation Just for this...
-  #define ___WE_UNDEFINED_DEPRECATED__
+#ifdef HAVE_TR1
+#include <tr1/unordered_map>
+#define STDEXT std::tr1
+#else
+#include <unordered_map>
+#define STDEXT std
 #endif
- #include <ext/hash_map>
- #define STDEXT __gnu_cxx
-#if defined(___WE_UNDEFINED_DEPRECATED__)
-#define __DEPRECATED
-#endif
-#endif
 
-
 namespace vcg{
 
 
@@ -101,7 +89,7 @@
 	// the hash index directly the grid structure.
 	// We use a MultiMap because we need to store many object (faces) inside each cell of the grid.
 
-	typedef typename STDEXT::hash_multimap<Point3i, ObjType *, HashFunctor> HashType;
+	typedef typename STDEXT::unordered_multimap<Point3i, ObjType *, HashFunctor> HashType;
 	typedef typename HashType::iterator HashIterator;
 	HashType hash_table; // The real HASH TABLE **************************************
 
Index: vcg/complex/algorithms/clustering.h
===================================================================
--- vcg/complex/algorithms/clustering.h	(revision 5055)
+++ vcg/complex/algorithms/clustering.h	(working copy)
@@ -23,6 +23,7 @@
 
 #ifndef __VCGLIB_CLUSTERING
 #define __VCGLIB_CLUSTERING
+#include <config.h>
 
 #include<vcg/complex/complex.h>
 #include <vcg/complex/algorithms/clean.h>
@@ -35,24 +36,15 @@
 #include <limits>
 
 // some stuff for portable hashes...
-#ifdef WIN32
- #ifndef __MINGW32__
-  #include <hash_map>
-  #include <hash_set>
-  #define STDEXT stdext
- #else
-  #include <ext/hash_map>
-  #include <ext/hash_set>
-  #define STDEXT __gnu_cxx
- #endif
+#ifdef HAVE_TR1
+#include <tr1/unordered_map>
+#include <tr1/unordered_set>
+#define STDEXT std::tr1
 #else
- #include <ext/hash_map>
- #include <ext/hash_set>
- #define STDEXT __gnu_cxx
+#include <unordered_map>
+#include <unordered_set>
+#define STDEXT std
 #endif
-
-
-
 namespace vcg{
 namespace tri{
 #define HASH_P0 73856093
@@ -74,12 +66,20 @@
 
 // needed for gcc compilation
 #ifndef _MSC_VER
-}} namespace STDEXT {
+}} 
+namespace std {
+#ifdef HAVE_TR1
+  namespace tr1 {
+#endif
   template <> struct hash<vcg::tri::HashedPoint3i>{
-  inline	size_t	operator ()(const vcg::tri::HashedPoint3i &p) const {return size_t(p);}
-};
-} namespace vcg{ namespace tri{
+    inline	size_t	operator ()(const vcg::tri::HashedPoint3i &p) const {return size_t(p);}
+  };
+#ifdef HAVE_TR1
+  }
 #endif
+} 
+namespace vcg{ namespace tri{
+#endif
 
 //
 template<class MeshType  >
@@ -263,18 +263,13 @@
 
   BasicGrid<ScalarType> Grid;
 
-#ifdef _MSC_VER
-  STDEXT::hash_set<SimpleTri> TriSet;
-  typedef typename STDEXT::hash_set<SimpleTri>::iterator TriHashSetIterator;
-#else
   struct SimpleTriHashFunc{
     inline	size_t	operator ()(const SimpleTri &p) const {return size_t(p);}
   };
-  STDEXT::hash_set<SimpleTri,SimpleTriHashFunc> TriSet;
-  typedef typename STDEXT::hash_set<SimpleTri,SimpleTriHashFunc>::iterator TriHashSetIterator;
-#endif
+  STDEXT::unordered_set<SimpleTri,SimpleTriHashFunc> TriSet;
+  typedef typename STDEXT::unordered_set<SimpleTri,SimpleTriHashFunc>::iterator TriHashSetIterator;
 
-  STDEXT::hash_map<HashedPoint3i,CellType> GridCell;
+  STDEXT::unordered_map<HashedPoint3i,CellType> GridCell;
 
 
 	void AddPointSet(MeshType &m, bool UseOnlySelected=false)
@@ -317,7 +312,7 @@
 
   void SelectPointSet(MeshType &m)
   {
-        typename STDEXT::hash_map<HashedPoint3i,CellType>::iterator gi;
+    typename STDEXT::unordered_map<HashedPoint3i,CellType>::iterator gi;
                 UpdateSelection<MeshType>::VertexClear(m);
         for(gi=GridCell.begin();gi!=GridCell.end();++gi)
     {
@@ -333,7 +328,7 @@
         if (GridCell.empty()) return;
 
     Allocator<MeshType>::AddVertices(m,GridCell.size());
-    typename STDEXT::hash_map<HashedPoint3i,CellType>::iterator gi;
+    typename STDEXT::unordered_map<HashedPoint3i,CellType>::iterator gi;
     int i=0;
     for(gi=GridCell.begin();gi!=GridCell.end();++gi)
     {
@@ -353,7 +348,7 @@
     if (GridCell.empty())  return;
 
     Allocator<MeshType>::AddVertices(m,GridCell.size());
-    typename STDEXT::hash_map<HashedPoint3i,CellType>::iterator gi;
+    typename STDEXT::unordered_map<HashedPoint3i,CellType>::iterator gi;
     int i=0;
     for(gi=GridCell.begin();gi!=GridCell.end();++gi)
     {
